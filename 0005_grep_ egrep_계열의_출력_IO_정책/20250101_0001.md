# grep, egrep 계열의 출력 IO 정책
#
```aiignore
2025.01.01
``` 


### 1.이슈사항
```
실시간 로그 모니터링시

tail -f $LOG_FILE | grep(egrep) .... 

명령어로 모니터링을 할 때, 최신 출력이 늦는 경우가 있다.
```


### 2. 원인
```
로그 파일은 이슈가 없다.
로그 파일 생성은 정상이다.

tail 명령어도 이슈가 없다.
tail 명령어도 파일의 변화가 발생하면 바로 따라간다.

grep(egrep) 에 이슈가 있다.

grep(egrep)은 입력 타입에 따라 내부 출력버퍼 처리가 다르다.

1. grep 데이터 소스입력을 터미널에서 바로 실행할 경우 츌력시 라인기반 버퍼링으로 처리한다.
x) grep "AAA" ./aaa.txt

2. grep 데이터 소스 입력을 파이프 기반으로 연결할 경우에는 출력시 블록기반 버퍼로 처리한다.
ex) tail -f ./aaa.txt | grep "AAA" ..

블록버퍼 로 처리시 버퍼가 다 쳤을때 flush 되므로,
grep(egrep) 앞에서 매칭이 되더라도, 
출력이 안되는 문제가 발생한다.
```


### 3. 대책
```aiignore
grep(egrpe) 출력시 블록 버퍼가 아닌 라인 버퍼링을 적용한다.

tail -f AAA.txt | grep --line-buffered "AAA" 
tail -f ./APP.log | egrep --line-buffered -a "(AAA|BBB)" | egrep --line-buffered -a "(aaa|bbb)"

man grep 으로 설명을 보면 정확히 알 수 있다. 

...
--line-buffered
      Use line buffering on output.  This can cause a performance penalty.
...   
```


### 4. 정리  
```aiignore
IO 를 사용하는 것은 시스템콜을 사용하는 것이다.
즉 매번 flush 하면 매번 system call 호출하는 것으로서 성능에 문제가 발생한다.
따라서, 버퍼링을 통해 모아서 처리함으로서, 시스템콜을 최소화 해서 사용하는 것이다.

라인 버퍼 적용시, 버퍼가 차기전에 flush 하는 것으로서
당연히 성능상 더 손해다. 
man 페이지에서 언급한 페널티가 이것을 말한다.

다만, 성능 보다 목적이 중요한 상황이므로, (바로 인지하는 것이 더 가치있음) 사용하는 것이다.

목적 보다 성능이 더 중요하면(장비 비용이 비싸면), 기본 블록 버퍼를 사용하는 것이고
성능 보다 목적이 더 중요하면(빠른 인지를 통한 생산성 향상), 라인 버퍼링을 하는 것이다.    
```

### -- 끝 --
